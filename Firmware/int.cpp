/****************************************************************************
**	INCLUDE
****************************************************************************/

//type definition using the bit width and signedness
#include <stdint.h>
//define the ISR routune, ISR vector, and the sei() cli() function
#include <avr/interrupt.h>
//name all the register and bit
#include <avr/io.h>

//General purpose macros
#include "at_utils.h"
//AT4809 PORT macros definitions
#include "at4809_port.h"

#include "global.h"

/****************************************************************************
**GLOBAL VARS
****************************************************************************/

/****************************************************************************
** INTERRUPT SERVICE ROUTINE
*****************************************************************************
**	In the AT4809 ISR flags have to be cleared manually
****************************************************************************/

/****************************************************************************
**	RTC Periodic Interrupt
*****************************************************************************
**	Periodic interrupt generated by the RTC from it's independent clock source
**		system tick
**	Fastest tick for general fast operations
**		control system
**	Issue the execution of the control system for the motors
**		slow tick
**	Issue a slow tick meant for non time critical communication and housekeeping tasks
****************************************************************************/

ISR( RTC_PIT_vect )
{	
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------
	//Local prescaler
	
	//if: tick is not issued
	if (g_isr_flags.fast_tick == false)
	{
		//Issue a tick
		g_isr_flags.fast_tick = true;
	}
	//if: slow tick is already issued
	else
	{
		//ERR OVERRUN
		//The main application could not keep up with the previous slow tick. Raise the alarm
		ISSUE_ERROR(ge_error_code, Error_code::ERR_OVERRUN_FAST_TICK);
	}
	
	//----------------------------------------------------------------
	//	SLOW TICK
	//----------------------------------------------------------------
	//	Slow tick meant to handle slow services like LEDs
	
	//Prescaler
	static uint16_t pre_slow = 0;	
	//If: Tick
	if (pre_slow == 0)
	{
		//if: tick is not issued
		if (g_isr_flags.slow_tick == false)
		{
			//Issue a tick
			g_isr_flags.slow_tick = true;	
		}
		//if: tick is already issued
		else
		{
			//ERR OVERRUN
			//The main application could not keep up with the previous slow tick. Raise the alarm
			ISSUE_ERROR(ge_error_code, Error_code::ERR_OVERRUN_SLOW_TICK);
		}
		
	}
	//Increment, reset if counter is top before increment
	pre_slow = AT_TOP_INC( pre_slow, Prescaler::TOP_SLOW_TICK-1 );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
	//Manually clear the interrupt flag
	RTC.PITINTFLAGS = RTC_PI_bm;
}


